<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode Flashcards - Print Ready</title>
    <style>
        @page {
            size: A4;
            margin: 0.3cm;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            font-size: 9pt;
            line-height: 1.3;
        }
        
        .flashcard {
            width: 19cm;    /* Slightly narrower for better centering */
            height: auto;   /* Height adjusts to content */
            min-height: 12cm; /* Minimum height */
            border: 3px solid #333;
            page-break-after: always;
            padding: 1cm;   /* Even padding on all sides */
            position: relative;
            background: white;
            margin: 1cm auto; /* Center horizontally and vertically */
            box-sizing: border-box;
        }
        
        .flashcard.front {
            background: #f8f9fa;
        }
        
        .flashcard.back {
            background: #e9ecef;
        }
        
        .flashcard.easy { border-color: #28a745; border-width: 3px; }
        .flashcard.medium { border-color: #ffc107; border-width: 3px; }
        .flashcard.hard { border-color: #dc3545; border-width: 3px; }
        
        .header {
            font-weight: bold;
            font-size: 10pt;
            padding-bottom: 0.1in;
            border-bottom: 1px solid #666;
            margin-bottom: 0.15in;
        }
        
        .content {
            font-size: 8pt;
            white-space: pre-wrap;
        }
        
        .hints, .solution {
            margin-top: 0.15in;
            padding-top: 0.15in;
            border-top: 1px dashed #999;
        }
        
        .complexity {
            position: absolute;
            bottom: 0.25in;
            left: 0.25in;
            right: 0.25in;
            padding-top: 0.1in;
            border-top: 1px solid #999;
            font-size: 8pt;
            font-weight: bold;
        }
        
        code {
            background: #f4f4f4;
            padding: 0.05in;
            font-size: 7pt;
        }
        
        @media screen {
            body {
                background: #ddd;
                padding: 20px;
            }
            .flashcard {
                margin: 20px auto;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                border-radius: 4px;
            }
        }
        
        @media print {
            body {
                background: white;
                margin: 0;
                padding: 0;
            }
            .flashcard {
                margin: 1cm auto;  /* Keep centering when printing */
                box-shadow: none;
            }
            @page {
                margin: 0.3cm;
            }
        }
        
        @media print {
            body {
                background: white;
            }
            .no-print {
                display: none;
            }
        }
        
        pre {
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 10pt;  /* Bigger font since card is bigger */
            line-height: 1.4;
            margin: 0 auto;
            padding: 0;
            display: table;  /* Makes pre element shrink-wrap and center */
        }
    </style>
</head>
<body>
    <div class="no-print" style="text-align: center; padding: 20px; background: white; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <h1>ğŸ´ LeetCode Flashcards - Print Ready</h1>
        <p style="margin: 10px 0;"><strong>Total Problems:</strong> 9 problems Ã— 2 cards = 18 total cards</p>
        <p style="margin: 10px 0;"><strong>Print Instructions:</strong></p>
        <ol style="text-align: left; display: inline-block; margin: 10px auto;">
            <li>File â†’ Print (âŒ˜P / Ctrl+P)</li>
            <li>âœ… Check "Print background graphics"</li>
            <li>Select printer or "Save as PDF"</li>
            <li>Print double-sided for front/back (optional)</li>
            <li>Cut along borders (4Ã—6 inches each)</li>
        </ol>
        <p style="margin-top: 15px; color: #666;">ğŸ’¡ Tip: Print on cardstock for durability!</p>
    </div>

    <div class="flashcard front easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #1  Two Sum  ğŸŸ¢ Easy                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an array of integers nums and an integer      â”‚
â”‚  target, return indices of the two numbers such      â”‚
â”‚  that they add up to target. You may assume that     â”‚
â”‚  each ... Ex: In=[nums = [2,7,11,15], target = 9]    â”‚
â”‚  Out=[[0,1]]                                         â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Have we seen this element before?                 â”‚
â”‚  â€¢ What gives O(1) lookup/insert?                    â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Hash Table / Array & Hashing            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #1  Two Sum - SOLUTION                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use HashMap to store seen elements for O(1)         â”‚
â”‚  lookup                                              â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Create HashMap to store valueâ†’index              â”‚
â”‚  2. For each element:                                â”‚
â”‚  - Check if complement exists in map                 â”‚
â”‚  - If yes: return indices                            â”‚
â”‚  - If no: add current to map                         â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(n)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #125  Valid Palindrome  ğŸŸ¢ Easy                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  **LeetCode #125:** [Valid                           â”‚
â”‚  Palindrome](https://leetcode.com/problems/valid-pa  â”‚
â”‚  Ex: In=[s = "A man, a plan, a canal: Panama"]       â”‚
â”‚  Out=[true]                                          â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Check symmetry without reversing?                 â”‚
â”‚  â€¢ What if special chars scattered?                  â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Two Pointers                            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #125  Valid Palindrome - SOLUTION                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use two pointers from edges, skip                   â”‚
â”‚  non-alphanumeric independently with bounds          â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Initialize `left = 0`, `right = length - 1`      â”‚
â”‚  2. Skip non-alphanumeric from left (with `left < r  â”‚
â”‚  3. Skip non-alphanumeric from right (with `left <   â”‚
â”‚  4. Compare `toLowerCase(s[left])` with `toLowerCas  â”‚
â”‚  5. Move both pointers inward; return false on mism  â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(1)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #128  Longest Consecutive Sequence  ğŸŸ¡ Medium       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an unsorted array of integers nums, return    â”‚
â”‚  the length of the longest consecutive elements      â”‚
â”‚  sequence. You must write an algorithm that runs     â”‚
â”‚  in ... Ex: In=[nums = [100,4,200,1,3,2]] Out=[4]    â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ How to check if num-1 or num+1 exist quickly?     â”‚
â”‚  â€¢ How to avoid counting same sequence twice?        â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Hash Table / Array & Hashing            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #128  Longest Consecutive Seque - SOLUTION          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Only count from sequence starts (where num-1        â”‚
â”‚  doesn't exist). Iterate over HashSet, not array!    â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Build HashSet for O(1) lookups                   â”‚
â”‚  2. Iterate over HashSet (not array!)                â”‚
â”‚  3. If num-1 doesn't exist: sequence start           â”‚
â”‚  4. Count consecutive: numâ†’num+1â†’num+2...            â”‚
â”‚  5. Track max length                                 â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(n)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #217  Contains Duplicate  ğŸŸ¢ Easy                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an integer array nums, return true if any     â”‚
â”‚  value appears at least twice in the array, and      â”‚
â”‚  return false if every element is distinct. Ex:      â”‚
â”‚  In=[nums = [1,2,3,1]] Out=[true]                    â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Have we seen this element before?                 â”‚
â”‚  â€¢ What data structure gives O(1) lookup?            â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Hash Table / Array & Hashing            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #217  Contains Duplicate - SOLUTION                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use HashSet to track seen elements - if we see      â”‚
â”‚  an element that's already in the set, we found a    â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Create empty HashSet                             â”‚
â”‚  2. For each number in array                         â”‚
â”‚  3. If number exists in set: return true             â”‚
â”‚  4. Add number to set                                â”‚
â”‚  5. Return false (no duplicates found)               â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(n)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #238  Product of Array Except Self  ğŸŸ¡ Medium       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an integer array nums, return an array        â”‚
â”‚  answer such that answer[i] is equal to the          â”‚
â”‚  product of all the elements of nums except          â”‚
â”‚  nums[i]. The pro... Ex: In=[nums = [1,2,3,4]]       â”‚
â”‚  Out=[[24,12,8,6]]                                   â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Can we use prefix and suffix products?            â”‚
â”‚  â€¢ How to avoid division?                            â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Array Manipulation / Prefix-Suffix      â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #238  Product of Array Except S - SOLUTION          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use two passes - prefix products leftâ†’right,        â”‚
â”‚  then multiply by suffix products rightâ†’left,        â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Create result array                              â”‚
â”‚  2. Forward pass: Store prefix products in result    â”‚
â”‚  3. Backward pass: Multiply by suffix products       â”‚
â”‚  4. Each result[i] = (product of all left) Ã— (produ  â”‚
â”‚  5. Return result array                              â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(1)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #242  Valid Anagram  ğŸŸ¢ Easy                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given two strings s and t, return true if t is      â”‚
â”‚  an anagram of s, and false otherwise. An Anagram    â”‚
â”‚  is a word or phrase formed by rearranging the       â”‚
â”‚  lette... Ex: In=[s = "anagram", t = "nagaram"]      â”‚
â”‚  Out=[true]                                          â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Do both strings need same character frequencies?  â”‚
â”‚  â€¢ Can sorting help?                                 â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Hash Table / Array & Hashing            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back easy">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #242  Valid Anagram - SOLUTION                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Count character frequencies - two strings are       â”‚
â”‚  anagrams if they have identical character counts    â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Check if lengths differ (early return false)     â”‚
â”‚  2. Count frequency of each char in both strings     â”‚
â”‚  3. Compare frequency maps or arrays                 â”‚
â”‚  4. Return true if identical, false otherwise        â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(1)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #271  Encode and Decode Strings  ğŸŸ¡ Medium          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Design an algorithm to encode a list of strings     â”‚
â”‚  to a string. The encoded string is then sent        â”‚
â”‚  over the network and is decoded back to the         â”‚
â”‚  original l... Ex:                                   â”‚
â”‚  In=[["lint","code","love","you"]]                   â”‚
â”‚  Out=[["lint","code","love","you"]]                  â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Can delimiters appear in the data itself?         â”‚
â”‚  â€¢ How can length information help avoid collisions  â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: String Manipulation                     â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #271  Encode and Decode Strings - SOLUTION          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use length#string format - once we know length,     â”‚
â”‚  we can safely extract exact chars (delimiters       â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Encode: append length + "#" + string             â”‚
â”‚  2. Decode: read length, skip "#", extract chars     â”‚
â”‚  3. Reset pointers: j = i after each extraction      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(n)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #347  Top K Frequent Elements  ğŸŸ¡ Medium            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an integer array nums and an integer k,       â”‚
â”‚  return the k most frequent elements. You may        â”‚
â”‚  return the answer in any order. Ex: In=[nums =      â”‚
â”‚  [1,1,1,2,2,3], k = 2] Out=[[1,2]]                   â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ Need all sorted or just top k?                    â”‚
â”‚  â€¢ Can frequency be used as index?                   â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Top K Elements                          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #347  Top K Frequent Elements - SOLUTION            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use frequency as array index for O(n) bucket        â”‚
â”‚  sort                                                â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Count frequencies with HashMap                   â”‚
â”‚  2. Create buckets[n+1] or use heap                  â”‚
â”‚  3. Place elements in bucket[frequency]              â”‚
â”‚  4. Traverse highâ†’low, collect k items               â”‚
â”‚                                                      â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n)  ğŸ’¾ O(n)                                   â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    

    <div class="flashcard front medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #49  Group Anagrams  ğŸŸ¡ Medium                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  Given an array of strings strs, group the           â”‚
â”‚  anagrams together. You can return the answer in     â”‚
â”‚  any order. An Anagram is a word or phrase formed    â”‚
â”‚  by rearr... Ex: In=[strs =                          â”‚
â”‚  ["eat","tea","tan","ate","nat","bat"]]              â”‚
â”‚  Out=[[["bat"],["nat","tan"],["ate","eat","tea"]]]   â”‚
â”‚                                                      â”‚
â”‚  ğŸ’¡ HINTS:                                           â”‚
â”‚  â€¢ What do anagrams have in common when sorted?      â”‚
â”‚  â€¢ Can sorted string be a key?                       â”‚
â”‚                                                      â”‚
â”‚  ğŸ¯ PATTERN: Hash Table / Array & Hashing            â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
    <!-- BACK card -->
    <div class="flashcard back medium">
        <pre>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  #49  Group Anagrams - SOLUTION                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  ğŸ’¡ KEY INSIGHT:                                     â”‚
â”‚  Use sorted string as HashMap key - all anagrams     â”‚
â”‚  will have the same sorted representation and map    â”‚
â”‚                                                      â”‚
â”‚  ğŸ”¢ ALGORITHM:                                       â”‚
â”‚  1. Create HashMap<String, List<String>>             â”‚
â”‚  2. For each string: sort it                         â”‚
â”‚  3. Use sorted string as key                         â”‚
â”‚  4. Add original string to list at that key          â”‚
â”‚  5. Return all values from HashMap                   â”‚
â”‚                                                      â”‚
â”‚  â±ï¸  O(n Ã— m)  ğŸ’¾ O(n Ã— m)                           â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
    </div>
    
</body></html>